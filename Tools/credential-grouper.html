<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title id="pageTitle">Pengelompok Data Kredensial</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }
        textarea#dataInput {
            width: calc(100% - 22px);
            height: 200px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }
        .controls {
            text-align: center;
            margin-bottom: 25px;
        }
        .controls button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 18px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.3s ease;
        }
        .controls button:hover {
            background-color: #2980b9;
        }
        .group {
            margin-bottom: 25px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 15px;
            background-color: #fdfdfd;
        }
        .group h3 {
            margin-top: 0;
            color: #2980b9;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            word-break: break-all;
        }
        .group ul {
            list-style-type: none;
            padding-left: 0;
        }
        .group li, #output > div > div { /* Style for ungrouped items too */
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 8px 12px;
            margin-bottom: 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85em;
            word-break: break-all;
            display: flex;
            justify-content: space-between;
            align-items: center;
        } /* This was for the old list item structure, still relevant for items within a selected group */
         .group li .details, #output > div > div .details {
            /* This class seems unused, can be removed or repurposed if needed */
            font-size: 0.9em;
            color: #555;
        }
        .group li .original-line, #output > div > div .original-line {
             flex-grow: 1;
        }
        .error-message {
            color: red;
            font-style: italic;
            font-size: 0.9em;
        }
        .count {
            font-weight: normal;
            font-size: 0.8em;
            color: #777;
        }
        .parsed-info {
            font-size: 0.8em;
            color: #007bff;
            margin-left: 10px;
            white-space: pre-wrap; /* Allows line breaks within the preformatted text */
            background-color: #e9f5ff;
            padding: 3px 6px;
            border-radius: 3px;
            border: 1px dashed #b3d7ff;
            min-width: 200px; /* Ensure some minimum width for parsed info */
        }
        .partial-remove-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        .partial-remove-controls input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .partial-remove-controls button {
            background-color: #e74c3c; /* Red for destructive action */
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.3s ease;
        }

        .parsed-info.hidden {
            display: none;
        }

        #groupButtonsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 8px; /* Spacing between buttons */
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .group-selector-button {
            background-color: #5cb85c; /* Green for group selectors */
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .group-selector-button:hover {
            background-color: #4cae4c;
        }

        .group li, #output > div > div { /* Selector for ungrouped items in showAllParsed */
            cursor: pointer; /* Indicate clickable items */
        }
        .language-switcher {
            text-align: center;
            margin-bottom: 20px;
        }
        .language-switcher button {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .language-switcher button:hover {
            background-color: #5a6268;
        }
        .language-switcher button.active {
            background-color: #007bff;
        }
        .copy-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 18px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.3s ease;
        }
        .copy-button:hover:not(:disabled) {
            background-color: #2980b9;
        }
        .copy-button:disabled {
            background-color: #28a745; /* Green for success */
            cursor: default;
        }

    </style>
</head>
<body onload="initializePage()">
    <div class="container">
        <div class="language-switcher">
            <button id="btnLangId" onclick="setLanguage('id')">Bahasa Indonesia</button>
            <button id="btnLangEn" onclick="setLanguage('en')">English</button>
        </div>
        <h1 id="mainHeader">Pengelompok Data Kredensial</h1>
        <p id="appDescription">Salin dan tempel data dari file teks Anda ke dalam area teks di bawah ini. Setiap baris data diharapkan dalam format <code>url:username:password</code> atau <code>username:password::url</code>.</p>
        <textarea id="dataInput" placeholder="Contoh: domain.com/login:pengguna123:sandiRahasia ATAU pengguna@email.com:sandiEmail::domain.com/login"></textarea>
        
        <div class="partial-remove-controls">
            <input type="text" id="partialTextToRemove" placeholder="Ketik teks yang ingin dihapus dari setiap baris">
            <button id="btnRemovePartial" onclick="removePartialText()">Hapus Teks Parsial</button>
        </div>

        
        <div class="controls">
            <button id="btnGroupByUrl" onclick="processAndGroup('url')">Kelompokkan berdasarkan URL</button>
            <button id="btnGroupByUsername" onclick="processAndGroup('username')">Kelompokkan berdasarkan Username</button>
            <button id="btnGroupByPassword" onclick="processAndGroup('password')">Kelompokkan berdasarkan Password</button>
            <button id="btnGroupByDomain" onclick="processAndGroup('domain')">Kelompokkan berdasarkan Domain</button>
            <button id="btnRemoveDuplicates" onclick="removeDuplicateLinesFromTextarea()">Hapus Duplikat dari Textarea</button>
            <button id="btnSortTextarea" onclick="sortTextarea()">Urutkan Textarea</button>
            <button id="btnShowAllParsed" onclick="showAllParsed()">Tampilkan Semua (Diparsing)</button>
        </div>
        
        <div id="output">
            <p id="resultsPlaceholder">Hasil pengelompokan akan ditampilkan di sini.</p>
        </div>
    </div>

    <script>
        let parsedEntriesGlobal = [];
        let currentLanguage = 'id';
        window.lastAction = null;
        window.lastGroupKey = null;

        const translations = {
            id: {
                pageTitle: "Pengelompok Data Kredensial",
                mainHeader: "Pengelompok Data Kredensial",
                appDescription: "Salin dan tempel data dari file teks Anda ke dalam area teks di bawah ini. Setiap baris data diharapkan dalam format <code>url:username:password</code> atau <code>username:password::url</code>.",
                textareaPlaceholder: "Contoh: domain.com/login:pengguna123:sandiRahasia ATAU pengguna@email.com:sandiEmail::domain.com/login",
                btnGroupByUrl: "Kelompokkan berdasarkan URL",
                btnGroupByUsername: "Kelompokkan berdasarkan Username",
                btnGroupByPassword: "Kelompokkan berdasarkan Password",
                btnGroupByDomain: "Kelompokkan berdasarkan Domain",
                btnRemoveDuplicates: "Hapus Duplikat dari Textarea",
                btnRemovePartial: "Hapus Teks Parsial",
                partialTextPlaceholder: "Ketik teks yang ingin dihapus dari setiap baris",
                btnSortTextarea: "Urutkan Textarea",
                btnShowAllParsed: "Tampilkan Semua (Diparsing)",
                resultsPlaceholder: "Hasil pengelompokan akan ditampilkan di sini.",
                errorInvalidEmptyUrl: "URL Tidak Valid/Kosong",
                errorEmptyUrl: "URL Kosong",
                errorNonStandardUrlFormat: "Format URL Tidak Standar",
                errorEmptyHostname: "Hostname Kosong",
                errorDomainNotExtractable: "Domain Tidak Dapat Diekstrak",
                errorFormatColonPasswordDoubleColonUrl: "Format :password::url tidak standar, username diasumsikan kosong.",
                errorFormatUserPassEndsColonDoubleColonUrl: (p) => `Format ${p}::url (username diakhiri :) tidak standar, password diasumsikan kosong.`,
                errorFormat2PartUrlUser: "Format 2 bagian, diasumsikan url:username (password kosong).",
                errorFormat2PartUserPass: "Format 2 bagian, diasumsikan username:password (URL kosong).",
                errorFormat1Part: (type) => `Format 1 bagian, diasumsikan sebagai ${type === 'username' ? translations.id.keyNameUsername : translations.id.keyNameUrl} (lainnya kosong).`,
                errorNotEnoughParts: "Baris tidak memiliki cukup bagian untuk diparsing.",
                errorTextareaEmpty: "Area teks kosong. Silakan masukkan data.",
                errorPartialTextEmpty: "Silakan masukkan teks yang ingin dihapus.",
                groupKeyCannotParse: "Tidak Dapat Diparsing/Error",
                groupKeyEmptyKeyData: "Data Kunci Kosong",
                statusNoDataToDisplay: "Tidak ada data untuk ditampilkan atau dikelompokkan.",
                entriesSuffix: "entri",
                parsedInfoLabelUrl: "URL",
                parsedInfoLabelUser: "User",
                parsedInfoLabelPass: "Pass",
                parsedInfoLabelInfo: "Info Parsing",
                emptyPlaceholder: "[kosong]",
                statusNoDataParsed: "Tidak ada data yang berhasil diparsing. Periksa format input.",
                showAllTitle: "Semua Entri (Diparsing)",
                keyNameUrl: "URL",
                keyNameUsername: "Username",
                keyNamePassword: "Password",
                keyNameDomain: "Domain",
                statusTextareaEmptyNoDuplicates: "Textarea kosong, tidak ada duplikat untuk dihapus.",
                statusDuplicatesRemoved: (orig, uniq) => `Proses hapus duplikat selesai. Jumlah baris asli (tidak kosong): ${orig}. Jumlah baris unik (termasuk baris kosong signifikan): ${uniq}.`,
                specialGroupKeyError: "Tidak Dapat Diparsing/Error",
                specialGroupKeyInvalidUrl: "URL Tidak Valid/Kosong",
                specialGroupKeyEmptyUrl: "URL Kosong",
                specialGroupKeyNonStandardUrl: "Format URL Tidak Standar",
                specialGroupKeyEmptyHostname: "Hostname Kosong",
                specialGroupKeyDomainNotExtractable: "Domain Tidak Dapat Diekstrak",
                specialGroupKeyEmptyData: "Data Kunci Kosong",
                domainListTitle: "Daftar Domain (untuk disalin)",
                copyDomainListButton: "Salin Daftar Domain",
                copyDomainListButtonSuccess: "Tersalin!",
                errorCopyFailed: "Gagal menyalin. Silakan salin secara manual.",
            },
            en: {
                pageTitle: "Credential Data Grouper",
                mainHeader: "Credential Data Grouper",
                appDescription: "Copy and paste data from your text file into the text area below. Each line of data is expected in the format <code>url:username:password</code> or <code>username:password::url</code>.",
                textareaPlaceholder: "Example: domain.com/login:user123:secretPassword OR user@email.com:emailPassword::domain.com/login",
                btnGroupByUrl: "Group by URL",
                btnGroupByUsername: "Group by Username",
                btnGroupByPassword: "Group by Password",
                btnGroupByDomain: "Group by Domain",
                btnRemoveDuplicates: "Remove Duplicates from Textarea",
                btnRemovePartial: "Remove Partial Text",
                partialTextPlaceholder: "Type text to remove from each line",
                btnSortTextarea: "Sort Textarea",
                btnShowAllParsed: "Show All (Parsed)",
                resultsPlaceholder: "Grouping results will be displayed here.",
                errorInvalidEmptyUrl: "Invalid/Empty URL",
                errorEmptyUrl: "Empty URL",
                errorNonStandardUrlFormat: "Non-Standard URL Format",
                errorEmptyHostname: "Empty Hostname",
                errorDomainNotExtractable: "Domain Cannot Be Extracted",
                errorFormatColonPasswordDoubleColonUrl: "Format :password::url is non-standard, username assumed empty.",
                errorFormatUserPassEndsColonDoubleColonUrl: (p) => `Format ${p}::url (username ends with :) is non-standard, password assumed empty.`,
                errorFormat2PartUrlUser: "2-part format, assumed url:username (password empty).",
                errorFormat2PartUserPass: "2-part format, assumed username:password (URL empty).",
                errorFormat1Part: (type) => `1-part format, assumed as ${type === 'username' ? translations.en.keyNameUsername : translations.en.keyNameUrl} (others empty).`,
                errorNotEnoughParts: "Line does not have enough parts to parse.",
                errorTextareaEmpty: "Text area is empty. Please enter data.",
                errorPartialTextEmpty: "Please enter the text you want to remove.",
                groupKeyCannotParse: "Cannot Be Parsed/Error",
                groupKeyEmptyKeyData: "Empty Key Data",
                statusNoDataToDisplay: "No data to display or group.",
                entriesSuffix: "entries",
                parsedInfoLabelUrl: "URL",
                parsedInfoLabelUser: "User",
                parsedInfoLabelPass: "Pass",
                parsedInfoLabelInfo: "Parsing Info",
                emptyPlaceholder: "[empty]",
                statusNoDataParsed: "No data was successfully parsed. Check the input format.",
                showAllTitle: "All Entries (Parsed)",
                keyNameUrl: "URL",
                keyNameUsername: "Username",
                keyNamePassword: "Password",
                keyNameDomain: "Domain",
                statusTextareaEmptyNoDuplicates: "Textarea is empty, no duplicates to remove.",
                statusDuplicatesRemoved: (orig, uniq) => `Duplicate removal process finished. Original non-empty line count: ${orig}. Unique line count (including significant empty lines): ${uniq}.`,
                specialGroupKeyError: "Cannot Be Parsed/Error",
                specialGroupKeyInvalidUrl: "Invalid/Empty URL",
                specialGroupKeyEmptyUrl: "Empty URL",
                specialGroupKeyNonStandardUrl: "Non-Standard URL Format",
                specialGroupKeyEmptyHostname: "Empty Hostname",
                specialGroupKeyDomainNotExtractable: "Domain Cannot Be Extracted",
                specialGroupKeyEmptyData: "Empty Key Data",
                domainListTitle: "Domain List (for copying)",
                copyDomainListButton: "Copy Domain List",
                copyDomainListButtonSuccess: "Copied!",
                errorCopyFailed: "Failed to copy. Please copy manually.",
            }
        };

        function T(key, ...args) {
            const langPack = translations[currentLanguage];
            if (!langPack || typeof langPack[key] === 'undefined') {
                console.warn(`Translation key "${key}" not found for language "${currentLanguage}". Falling back to ID.`);
                const fallbackLangPack = translations['id'];
                if (fallbackLangPack && typeof fallbackLangPack[key] !== 'undefined') {
                    const fallbackString = fallbackLangPack[key];
                    return typeof fallbackString === 'function' ? fallbackString(...args) : fallbackString;
                }
                return key; // Return key itself if not found in ID either
            }
            const stringOrFn = langPack[key];
            return typeof stringOrFn === 'function' ? stringOrFn(...args) : stringOrFn;
        }

        function updateUIText() {
            document.getElementById('pageTitle').textContent = T('pageTitle');
            document.getElementById('mainHeader').textContent = T('mainHeader');
            document.getElementById('appDescription').innerHTML = T('appDescription');
            document.getElementById('dataInput').placeholder = T('textareaPlaceholder');

            document.getElementById('btnGroupByUrl').textContent = T('btnGroupByUrl');
            document.getElementById('btnGroupByUsername').textContent = T('btnGroupByUsername');
            document.getElementById('btnGroupByPassword').textContent = T('btnGroupByPassword');
            document.getElementById('btnGroupByDomain').textContent = T('btnGroupByDomain');
            document.getElementById('btnRemoveDuplicates').textContent = T('btnRemoveDuplicates');
            document.getElementById('btnRemovePartial').textContent = T('btnRemovePartial');
            document.getElementById('partialTextToRemove').placeholder = T('partialTextPlaceholder');
            document.getElementById('btnSortTextarea').textContent = T('btnSortTextarea');
            document.getElementById('btnShowAllParsed').textContent = T('btnShowAllParsed');
            
            document.getElementById('btnLangId').classList.toggle('active', currentLanguage === 'id');
            document.getElementById('btnLangEn').classList.toggle('active', currentLanguage === 'en');

            const outputDiv = document.getElementById('output');
            const resultsPlaceholderP = outputDiv.querySelector('p#resultsPlaceholder');
            if (resultsPlaceholderP || outputDiv.innerHTML.includes(translations.id.resultsPlaceholder) || outputDiv.innerHTML.includes(translations.en.resultsPlaceholder)) {
                 outputDiv.innerHTML = `<p id="resultsPlaceholder">${T('resultsPlaceholder')}</p>`;
            }
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            updateUIText();

            if (window.lastAction === 'group' && window.lastGroupKey) {
                processAndGroup(window.lastGroupKey, true);
            } else if (window.lastAction === 'showAll') {
                showAllParsed(true);
            } else {
                const outputDiv = document.getElementById('output');
                 if (!outputDiv.querySelector('p#resultsPlaceholder') && !outputDiv.innerHTML.includes(T('resultsPlaceholder'))) {
                    outputDiv.innerHTML = `<p id="resultsPlaceholder">${T('resultsPlaceholder')}</p>`;
                }
            }
        }

        function initializePage() {
            const userLang = navigator.language || navigator.userLanguage;
            if (userLang.startsWith('en')) {
                currentLanguage = 'en';
            } else {
                currentLanguage = 'id';
            }
            updateUIText();
            document.getElementById('output').innerHTML = `<p id="resultsPlaceholder">${T('resultsPlaceholder')}</p>`;
        }

        function extractDomain(urlString) {
            if (!urlString || typeof urlString !== 'string') {
                return T('errorInvalidEmptyUrl');
            }
            let trimmedUrl = urlString.trim();
            if (trimmedUrl === '') {
                return T('errorEmptyUrl');
            }

            // Coba tambahkan protokol jika tidak ada, karena konstruktor URL membutuhkannya
            let parsableUrl = trimmedUrl;
            if (!parsableUrl.match(/^[\w.-]+:\/\//)) {
                // Jika terlihat seperti domain (misalnya, example.com/path atau hanya example.com)
                if (parsableUrl.includes('.') && !parsableUrl.startsWith('/') && !parsableUrl.includes(' ')) {
                    parsableUrl = 'http://' + parsableUrl;
                } else {
                    // Tidak terlihat seperti domain yang bisa dikoreksi otomatis dengan http://
                    return T('errorNonStandardUrlFormat');
                }
            }

            try {
                const url = new URL(parsableUrl);
                let hostname = url.hostname;
                if (hostname) {
                    // Hapus 'www.' jika ada untuk mengelompokkan www.domain.com dan domain.com bersama-sama
                    if (hostname.startsWith('www.')) {
                        hostname = hostname.substring(4);
                    }
                    return hostname;
                } else {
                    // URL dapat diparsing tetapi hostname kosong (misalnya "http://")
                    return T('errorEmptyHostname');
                }
            } catch (e) {
                return T('errorDomainNotExtractable'); // Fallback untuk URL yang tidak dapat diparsing
            }
        }

        function parseEntry(lineStr) {
            const line = lineStr.trim();
            if (!line) return null;
            let url = '', username = '', password = '', error = null, errorParams = [];

            const doubleColonIndex = line.indexOf('::');

            if (doubleColonIndex !== -1) {
                // Format is likely username:password::url (or variations)
                const userPassPartRaw = line.substring(0, doubleColonIndex);
                const urlPartRaw = line.substring(doubleColonIndex + 2);
                
                url = urlPartRaw.trim(); 

                const userPassPart = userPassPartRaw.trim();
                if (userPassPart === '') { 
                    username = '';
                    password = '';
                } else {
                    const lastColonInUserPass = userPassPart.lastIndexOf(':');
                    if (lastColonInUserPass === -1) { 
                        username = userPassPart;
                        password = '';
                    } else if (lastColonInUserPass === 0 && userPassPart.length > 1) { 
                        username = ''; 
                        password = userPassPart.substring(1).trim();
                        error = 'errorFormatColonPasswordDoubleColonUrl';
                    } else if (lastColonInUserPass === userPassPart.length - 1) { 
                        username = userPassPart.substring(0, lastColonInUserPass).trim();
                        password = '';
                        // error = 'Format ' + userPassPart + '::url (username diakhiri :) tidak standar, password diasumsikan kosong.';
                        error = 'errorFormatUserPassEndsColonDoubleColonUrl';
                        errorParams = [userPassPart];
                    } else { 
                        username = userPassPart.substring(0, lastColonInUserPass).trim();
                        password = userPassPart.substring(lastColonInUserPass + 1).trim();
                    }
                }
            } else {
                // No '::', parse as url:username:password or heuristics
                const parts = line.split(':');
                if (parts.length >= 3) {
                    password = parts.pop().trim();
                    username = parts.pop().trim();
                    url = parts.join(':').trim();
                } else if (parts.length === 2) {
                    const part1 = parts[0].trim();
                    const part2 = parts[1].trim();
                    // Heuristic: if first part looks like a URL (contains . and / or http/www)
                    if (part1.includes('.') && (part1.includes('/') || part1.toLowerCase().startsWith('http') || part1.toLowerCase().startsWith('www'))) {
                        url = part1;
                        username = part2;
                        password = '';
                        error = 'errorFormat2PartUrlUser';
                    } else { 
                        username = part1;
                        password = part2;
                        url = '';
                        error = 'errorFormat2PartUserPass';
                    }
                } else if (parts.length === 1 && line.length > 0) {
                    const singlePart = line.trim(); 
                    // Heuristic for 1 part: username (contains @ or no . and no /) OR URL
                    if (singlePart.includes('@') || (!singlePart.includes('.') && !singlePart.includes('/'))) {
                       username = singlePart;
                       url = '';
                       password = '';
                    } else {
                       url = singlePart;
                       username = '';
                       password = '';
                    }
                    error = 'errorFormat1Part';
                    errorParams = [(username ? 'username' : 'URL')];
                } else {
                    // Not enough parts to parse meaningfully or empty line after trim (though initial check should catch this)
                    return { original: line, url:'', username:'', password:'', error: 'errorNotEnoughParts', errorParams: [] };
                }
            }
            
            return { url, username, password, original: line, error, errorParams };
        }

        function parseAllData() {
            const dataString = document.getElementById('dataInput').value;
            if (!dataString.trim()) {
                document.getElementById('output').innerHTML = `<p class="error-message">${T('errorTextareaEmpty')}</p>`;
                return [];
            }
            // Split by newline characters (handles Unix, Windows, and old Mac line endings)
            const lines = dataString.split(/\r?\n/);
            const entries = [];
            lines.forEach(line => {
                const entry = parseEntry(line);
                if (entry) { // parseEntry now always returns an object or null
                    entries.push(entry);
                }
            });
            return entries;
        }

        function groupBy(entries, key) {
            if (!entries || entries.length === 0) return {};
            return entries.reduce((acc, entry) => {
                // If entry has an error, its specific key (url, username, password) might be empty.
                let groupKeyVal = entry[key];
                if (entry.error) {
                    groupKeyVal = T('groupKeyCannotParse'); // Use translated key for grouping errors
                } else if (key === 'domain') {
                    groupKeyVal = extractDomain(entry.url); 
                } else if (groupKeyVal === null || groupKeyVal === undefined || groupKeyVal.trim() === '') {
                    groupKeyVal = T('groupKeyEmptyKeyData'); // Use translated key for empty data
                }

                if (!acc[groupKeyVal]) {
                    acc[groupKeyVal] = [];
                }
                acc[groupKeyVal].push(entry);
                return acc;
            }, {});
        }

        function displayGroupedData(groupedData, groupByKeyName) {
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = ''; // Clear previous output

            if (Object.keys(groupedData).length === 0) {
                outputDiv.innerHTML = `<p>${T('statusNoDataToDisplay')}</p>`;
                return;
            }

            // NEW: Add domain list textarea if grouping by domain
            if (window.lastGroupKey === 'domain') {
                const specialKeys = [
                    T('groupKeyCannotParse'), 
                    T('errorInvalidEmptyUrl'), 
                    T('errorEmptyUrl'), 
                    T('errorNonStandardUrlFormat'),
                    T('errorEmptyHostname'),
                    T('errorDomainNotExtractable'),
                    T('groupKeyEmptyKeyData')
                ];
                
                const domainList = Object.keys(groupedData)
                                         .filter(key => !specialKeys.includes(key))
                                         .sort(); // Sort alphabetically

                if (domainList.length > 0) {
                    const domainListContainer = document.createElement('div');
                    domainListContainer.style.marginBottom = '20px';

                    const label = document.createElement('h4');
                    label.textContent = T('domainListTitle');
                    label.style.color = '#2c3e50';
                    domainListContainer.appendChild(label);

                    const textarea = document.createElement('textarea');
                    textarea.readOnly = true;
                    textarea.style.width = 'calc(100% - 22px)';
                    textarea.style.height = '150px';
                    textarea.style.fontFamily = "'Courier New', Courier, monospace";
                    textarea.value = domainList.join('\n');
                    domainListContainer.appendChild(textarea);

                    const copyButton = document.createElement('button');
                    copyButton.textContent = T('copyDomainListButton');
                    copyButton.className = 'copy-button';
                    copyButton.onclick = function() {
                        navigator.clipboard.writeText(textarea.value).then(() => {
                            copyButton.textContent = T('copyDomainListButtonSuccess');
                            copyButton.disabled = true;
                            setTimeout(() => {
                                copyButton.textContent = T('copyDomainListButton');
                                copyButton.disabled = false;
                            }, 2000);
                        }).catch(err => {
                            console.error('Failed to copy: ', err);
                            alert(T('errorCopyFailed'));
                        });
                    };
                    domainListContainer.appendChild(copyButton);
                    outputDiv.appendChild(domainListContainer);
                }
            }

            const groupButtonsContainer = document.createElement('div');
            groupButtonsContainer.id = 'groupButtonsContainer';

            const groupItemsDisplayDiv = document.createElement('div');
            groupItemsDisplayDiv.id = 'groupItemsDisplayDiv';

            outputDiv.appendChild(groupButtonsContainer);
            outputDiv.appendChild(groupItemsDisplayDiv);

            const sortedGroupKeys = Object.keys(groupedData).sort((a, b) => {
                // Handle special keys for sorting (e.g., error categories at the bottom or top)
                const specialKeysOrder = [
                    T('groupKeyCannotParse'), 
                    T('errorInvalidEmptyUrl'), 
                    T('errorEmptyUrl'), 
                    T('errorNonStandardUrlFormat'),
                    T('errorEmptyHostname'),
                    T('errorDomainNotExtractable'),
                    T('groupKeyEmptyKeyData')
                ];
                const aIsSpecial = specialKeysOrder.includes(a);
                const bIsSpecial = specialKeysOrder.includes(b);

                if (aIsSpecial && !bIsSpecial) return 1; // Special keys go to bottom
                if (!aIsSpecial && bIsSpecial) return -1;
                if (aIsSpecial && bIsSpecial) return specialKeysOrder.indexOf(a) - specialKeysOrder.indexOf(b);
                
                // Sort by count descending, then by key ascending
                return groupedData[b].length - groupedData[a].length || a.localeCompare(b);
            });

            const keyTranslationMap = {
                [translations.id.errorInvalidEmptyUrl]: 'specialGroupKeyInvalidUrl', [translations.en.errorInvalidEmptyUrl]: 'specialGroupKeyInvalidUrl',
                [translations.id.errorEmptyUrl]: 'specialGroupKeyEmptyUrl', [translations.en.errorEmptyUrl]: 'specialGroupKeyEmptyUrl',
                [translations.id.errorNonStandardUrlFormat]: 'specialGroupKeyNonStandardUrl', [translations.en.errorNonStandardUrlFormat]: 'specialGroupKeyNonStandardUrl',
                [translations.id.errorEmptyHostname]: 'specialGroupKeyEmptyHostname', [translations.en.errorEmptyHostname]: 'specialGroupKeyEmptyHostname',
                [translations.id.errorDomainNotExtractable]: 'specialGroupKeyDomainNotExtractable', [translations.en.errorDomainNotExtractable]: 'specialGroupKeyDomainNotExtractable',
                [translations.id.groupKeyCannotParse]: 'specialGroupKeyError', [translations.en.groupKeyCannotParse]: 'specialGroupKeyError',
                [translations.id.groupKeyEmptyKeyData]: 'specialGroupKeyEmptyData', [translations.en.groupKeyEmptyKeyData]: 'specialGroupKeyEmptyData',
            };

            sortedGroupKeys.forEach(key => {
                const entries = groupedData[key];
                const groupButton = document.createElement('button');
                groupButton.className = 'group-selector-button'; 

                groupButton.addEventListener('click', function() {
                    // Clear previous items
                    groupItemsDisplayDiv.innerHTML = '';

                    // Display items for this group
                    const groupContentDiv = document.createElement('div');
                    groupContentDiv.className = 'group'; // Reuse existing styling for the list container

                    const title = document.createElement('h3');
                    let displayKeyTextForTitle = key;
                    if (keyTranslationMap[key]) {
                        displayKeyTextForTitle = T(keyTranslationMap[key]);
                    }

                    const groupByKeyDisplay = groupByKeyName === T('keyNameUrl') ? T('keyNameUrl') :
                                         groupByKeyName === T('keyNameUsername') ? T('keyNameUsername') :
                                         groupByKeyName === T('keyNamePassword') ? T('keyNamePassword') :
                                         groupByKeyName === T('keyNameDomain') ? T('keyNameDomain') : groupByKeyName;

                    title.textContent = `${groupByKeyDisplay}: ${displayKeyTextForTitle} `;


                    const countSpan = document.createElement('span');
                    countSpan.className = 'count';
                    countSpan.textContent = `(${entries.length} ${T('entriesSuffix')})`;
                    title.appendChild(countSpan);
                    groupContentDiv.appendChild(title);

                    const ul = document.createElement('ul');
                    entries.forEach(entry => {
                        const li = document.createElement('li');

                        const originalLineSpan = document.createElement('span');
                        originalLineSpan.className = 'original-line';
                        originalLineSpan.textContent = entry.original;
                        li.appendChild(originalLineSpan);

                        const parsedInfoSpan = document.createElement('span');
                        parsedInfoSpan.className = 'parsed-info';

                        let infoHTML = `${T('parsedInfoLabelUrl')}: ${entry.url || T('emptyPlaceholder')}<br>${T('parsedInfoLabelUser')}: ${entry.username || T('emptyPlaceholder')}<br>${T('parsedInfoLabelPass')}: ${entry.password || T('emptyPlaceholder')}`;
                        if (entry.error) {
                            parsedInfoSpan.classList.add('error-message');
                            const errorDisplay = T(entry.error, ...(entry.errorParams || []));
                            infoHTML += `<br><span style="font-style:italic;">${T('parsedInfoLabelInfo')}: ${errorDisplay}</span>`;
                        }
                        parsedInfoSpan.innerHTML = infoHTML;
                        li.appendChild(parsedInfoSpan);
                        ul.appendChild(li);

                        // Initially hide details and add click listener to toggle
                        parsedInfoSpan.classList.add('hidden');
                        li.addEventListener('click', function(event) {
                            const details = this.querySelector('.parsed-info');
                            if (details) {
                                details.classList.toggle('hidden');
                            }
                        });
                    });
                    groupContentDiv.appendChild(ul);
                    groupItemsDisplayDiv.appendChild(groupContentDiv);
                });

                let displayKeyTextForButton = key;
                 if (keyTranslationMap[key]) {
                    displayKeyTextForButton = T(keyTranslationMap[key]);
                }
                 // Memberikan warna berbeda untuk kategori khusus
                if (keyTranslationMap[key]) { // Check if the original key (before translation for display) is a special one
                    groupButton.style.backgroundColor = '#f0ad4e'; // Oranye untuk peringatan/kategori khusus
                }
                groupButton.textContent = `${displayKeyTextForButton} (${entries.length} ${T('entriesSuffix')})`;
                groupButtonsContainer.appendChild(groupButton);
            });
        }
        
        function showAllParsed(fromLanguageChange = false) {
            if (!fromLanguageChange) {
                parsedEntriesGlobal = parseAllData();
                if (parsedEntriesGlobal.length === 0 && document.getElementById('dataInput').value.trim()) {
                    document.getElementById('output').innerHTML = `<p class="error-message">${T('statusNoDataParsed')}</p>`;
                    return;
                } else if (parsedEntriesGlobal.length === 0) {
                    return; 
                }
            }
            window.lastAction = 'showAll';
            window.lastGroupKey = null;

            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = `<h2>${T('showAllTitle')}</h2>`;
            const containerDiv = document.createElement('div');
            parsedEntriesGlobal.forEach(entry => {
                const itemDiv = document.createElement('div'); // Using div instead of li for ungrouped items
                    
                const originalLineSpan = document.createElement('span');
                originalLineSpan.className = 'original-line';
                originalLineSpan.textContent = entry.original;
                itemDiv.appendChild(originalLineSpan);

                const parsedInfoSpan = document.createElement('span');
                parsedInfoSpan.className = 'parsed-info';
                let infoHTML = `${T('parsedInfoLabelUrl')}: ${entry.url || T('emptyPlaceholder')}<br>${T('parsedInfoLabelUser')}: ${entry.username || T('emptyPlaceholder')}<br>${T('parsedInfoLabelPass')}: ${entry.password || T('emptyPlaceholder')}`;
                if (entry.error) {
                    parsedInfoSpan.classList.add('error-message');
                    const errorDisplay = T(entry.error, ...(entry.errorParams || []));
                    infoHTML += `<br><span style="font-style:italic;">${T('parsedInfoLabelInfo')}: ${errorDisplay}</span>`;
                }
                parsedInfoSpan.innerHTML = infoHTML;
                itemDiv.appendChild(parsedInfoSpan);
                
                // Initially hide details and add click listener to toggle
                parsedInfoSpan.classList.add('hidden');
                itemDiv.addEventListener('click', function(event) {
                    const details = this.querySelector('.parsed-info');
                    if (details) {
                        details.classList.toggle('hidden');
                    }
                });

                containerDiv.appendChild(itemDiv);
            });
            outputDiv.appendChild(containerDiv);
        }

        function processAndGroup(keyName, fromLanguageChange = false) {
            if (!fromLanguageChange) {
                parsedEntriesGlobal = parseAllData();
                 if (parsedEntriesGlobal.length === 0 && document.getElementById('dataInput').value.trim()) {
                    document.getElementById('output').innerHTML = `<p class="error-message">${T('statusNoDataParsed')}</p>`;
                    return;
                } else if (parsedEntriesGlobal.length === 0) {
                    return; 
                }
            }
            window.lastAction = 'group';
            window.lastGroupKey = keyName;
            
            // Group all entries, including those with errors, based on the key or error status
            const grouped = groupBy(parsedEntriesGlobal, keyName);
            
            let keyNameDisplay = keyName;
            if (keyName === 'url') keyNameDisplay = T('keyNameUrl');
            else if (keyName === 'username') keyNameDisplay = T('keyNameUsername');
            else if (keyName === 'password') keyNameDisplay = T('keyNamePassword');
            else if (keyName === 'domain') keyNameDisplay = T('keyNameDomain');
            
            displayGroupedData(grouped, keyNameDisplay);
        }

        function removeDuplicateLinesFromTextarea() {
            const dataInput = document.getElementById('dataInput');
            const outputDiv = document.getElementById('output');
            const lines = dataInput.value.split(/\r?\n/);
            
            const originalLineCount = lines.filter(line => line.trim() !== '').length;
            if (originalLineCount === 0) {
                outputDiv.innerHTML = `<p class="error-message">${T('statusTextareaEmptyNoDuplicates')}</p>`;
                return;
            }

            const uniqueLines = new Set();
            const linesInOrder = [];

            lines.forEach(line => {
                const strippedLine = line.trim(); // Konsisten dengan logika Python, strip dulu
                if (strippedLine) { // Hanya proses baris yang tidak kosong setelah di-strip
                    if (!uniqueLines.has(strippedLine)) {
                        uniqueLines.add(strippedLine);
                        linesInOrder.push(line); // Simpan baris asli (dengan spasi awal/akhir jika ada, sebelum strip)
                    }
                } else if (line === '' && (linesInOrder.length === 0 || linesInOrder[linesInOrder.length -1] !== '')) {
                    // Simpan baris kosong jika itu adalah baris kosong yang signifikan (bukan bagian dari beberapa baris kosong berturut-turut)
                    linesInOrder.push(line); 
                }
            });
            dataInput.value = linesInOrder.join('\n');
            outputDiv.innerHTML = `<p>${T('statusDuplicatesRemoved', originalLineCount, linesInOrder.filter(line => line.trim() !== '').length)}</p>`;
        }

        function sortTextarea() {
            const dataInput = document.getElementById('dataInput');
            const lines = dataInput.value.split(/\r?\n/);
            lines.sort((a, b) => a.localeCompare(b)); // Use localeCompare for better sorting
            dataInput.value = lines.join('\n');
        }

        function removePartialText() {
            const textToRemoveInput = document.getElementById('partialTextToRemove');
            const textToRemove = textToRemoveInput.value;
            const dataInput = document.getElementById('dataInput');
            const outputDiv = document.getElementById('output');

            if (!textToRemove) {
                outputDiv.innerHTML = `<p class="error-message">${T('errorPartialTextEmpty')}</p>`;
                return;
            }

            // Escape special characters in the input string for use in a RegExp
            const escapedText = textToRemove.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const regex = new RegExp(escapedText, 'g');
            
            dataInput.value = dataInput.value.replace(regex, '');
            outputDiv.innerHTML = ''; // Clear any previous messages
        }
    </script>
</body>
</html>
